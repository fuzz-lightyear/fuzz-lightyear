const fs = require('fs')
const p = require('path')
const crypto = require('crypto')
const mkdirp = require('mkdirp')
const chalk = require('chalk')
const progress = require('cli-progress')
const { create } = require('../..')
const consts = require('../../consts')

const TEMPLATE_PATH = p.join(__dirname, '../../test.js.template')

exports.command = 'run'
exports.desc = 'Perform fuzz testing'
exports.builder = {
  config: {
    default: p.join(process.cwd(), 'fuzzing.config.js'),
    alias: 'c',
    description: 'Path to the fuzzing config file',
    type: 'string'
  },
  module: {
    default: p.join(process.cwd(), 'fuzzing.js'),
    alias: 'm',
    description: 'Path to the module to fuzz',
    type: 'string'
  },
  iterations: {
    alias: 'i',
    description: 'Number of fuzzing iterations to perform',
    type: 'number'
  },
  operations: {
    alias: 'o',
    descrption: 'Number of operations to execute per iteration',
    type: 'number'
  },
  seed: {
    alias: 's',
    description: 'The fuzzing seed',
    type: 'string'
  },
  debug: {
    alias: 'd',
    description: 'Show debugging information',
    type: 'boolean'
  },
  print: {
    alias: 'p',
    description: 'Only display the failing test',
    type: 'boolean',
    default: 'false'
  }
}
exports.handler = async function (argv) {
  const userFunctions = require(argv.module)

  var userConfig = require(argv.config)
  if (argv.operations) userConfig.numOperations = argv.operations
  if (argv.seed) userConfig.seed = argv.seed
  if (argv.debug) userConfig.debug = argv.debug
  if (argv.iterations) userConfig.numIterations = argv.iterations

  const failingTestRoot = p.join(p.dirname(argv.module), 'test', 'autogenerated','failing')

  const { events, run } = create(userFunctions, userConfig)
  var bar = null

  if (!argv.debug) {
    bar = new progress.SingleBar()
    bar.start(argv.iterations || userConfig.iterations, 0)
    events.on('progress', () => bar.increment())
  }
  try {
    await run()
    if (bar) bar.stop()
  } catch (err) {
    if (bar) bar.stop()
    if (!err[consts.FuzzError]) {
      console.error('Fuzzing produced unexpected error:', err)
    } else {
      const testCase = await generateTestCase(err, argv)
      console.log('Failing Test:\n')
      console.log(testCase)
      console.log()
      if (argv.print !== false) {
        const testPath = await writeTest(testCase, failingTestRoot)
        console.log()
      }
    }
  }
}

async function generateTestCase (err, argv) {
  const template = await new Promise((resolve, reject) => {
    fs.readFile(TEMPLATE_PATH, { encoding: 'utf8' }, (err, contents) => {
      if (err) return reject(err)
      return resolve(contents)
    })
  })

  const trace = err[consts.Trace]
  const operations = trace.map(t => `await op.${t.name}(${JSON.stringify(t.inputs).slice(1).slice(0, -1)})`).join('\n  ')

  const replacements = new Map([
    ['operations', operations],
    ['modulePath', argv.module],
    ['config', JSON.stringify(err[consts.Config], null, 1)],
    ['description', err[consts.Description]],
    ['testName', err[consts.TestName]],
    ['testArgs', JSON.stringify([...err[consts.TestArgs]]).slice(1).slice(0, -1)]
  ])

  var testCase = template
  for (const [name, value] of replacements) {
    testCase = testCase.replace(new RegExp(`\{\{ ${name} \}\}`, 'g'), value)
  }

  return testCase
}

async function getPath (failingTestRoot, testCase, offset = 8) {
  var hash = shasum(testCase)
  var name = p.join(failingTestRoot, `test-${hash.slice(0, offset)}.js`)

  const { exists, continue: cont } = await checkIfExists()
  if (!exists) return name
  if (!cont) return null

  if (offset >= hash.length) return null
  return getPath(failingTestRoot, hash, offset + 8)

  function shasum (testCase) {
    const sha = crypto.createHash('sha256')
    sha.update(testCase)
    return sha.digest('hex')
  }

  function checkIfExists () {
    return new Promise((resolve, reject) => {
      fs.readFile(name, { encoding: 'utf8' }, (err, contents) => {
        if (err && err.errno !== -2 && err.errno !== -20) return reject(err)
        if (err) return resolve({ exists: false, continue: false})

        const fileHash = shasum(contents)
        if (fileHash === hash) return resolve({ exists: true, continue: false})

        return resolve({ exists: true, continue: true })
      })
    })
  }
}

async function writeTest (testCase, failingTestRoot) {
  const testPath = await getPath(failingTestRoot, testCase)
  if (!testPath) {
    console.log('Test case already exists. Not overwriting.')
    return
  }
  await new Promise((resolve, reject) => {
    mkdirp(failingTestRoot, err => {
      if (err) return reject(err)
      return resolve()
    })
  })
  await new Promise((resolve, reject) => {
    fs.writeFile(testPath, testCase, { encoding: 'utf8'}, err => {
      if (err) return reject(err)
      return resolve()
    })
  })
  console.log(`Test case written to: ${testPath}`)
  return testPath
}

