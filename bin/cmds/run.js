const fs = require('fs')
const p = require('path')
const crypto = require('crypto')
const mkdirp = require('mkdirp')
const chalk = require('chalk')
const progress = require('cli-progress')
const { create } = require('../..')
const consts = require('../../consts')

const TEMPLATE_PATH = p.join(__dirname, '../../test.js.template')

exports.command = 'run'
exports.desc = 'Perform fuzz testing'
exports.builder = {
  config: {
    default: p.join(process.cwd(), 'fuzzing.config.js'),
    alias: 'c',
    description: 'Path to the fuzzing config file',
    type: 'string'
  },
  module: {
    default: p.join(process.cwd(), 'fuzzing.js'),
    alias: 'm',
    description: 'Path to the module to fuzz',
    type: 'string'
  },
  iterations: {
    alias: 'i',
    description: 'Number of fuzzing iterations to perform',
    type: 'number'
  },
  operations: {
    alias: 'o',
    descrption: 'Number of operations to execute per iteration',
    type: 'number'
  },
  seed: {
    alias: 's',
    description: 'The fuzzing seed number',
    type: 'number'
  },
  debug: {
    alias: 'd',
    description: 'Show debugging information',
    type: 'boolean'
  },
  print: {
    alias: 'p',
    description: 'Only display the failing test',
    type: 'boolean',
    default: 'false'
  }
}
exports.handler = async function (argv) {
  const userFunctions = require(argv.module)

  var userConfig = require(argv.config)
  if (argv.operations) userConfig.numOperations = argv.operations
  if (argv.seed) userConfig.seedNumber = argv.seed
  if (argv.debug) userConfig.debug = argv.debug
  if (argv.iterations) userConfig.numIterations = argv.iterations

  const failingTestRoot = p.join(p.dirname(argv.module), 'test', 'autogenerated','failing')

  const { events, run } = create(userFunctions, userConfig)
  var bar = null

  if (!argv.debug) {
    bar = new progress.SingleBar()
    bar.start(argv.iterations || userConfig.numIterations, 0)
    events.on('progress', () => bar.increment())
  }
  try {
    await run()
    if (bar) bar.stop()
    console.log()
    console.log('Fuzzing Succeeded.')
    console.log()
  } catch (err) {
    if (bar) bar.stop()
    if (!err[consts.FuzzError]) {
      console.error('Fuzzing produced unexpected error:', err)
    } else {
      const { testCase, signature } = await generateTestCase(err, failingTestRoot, argv)
      console.log('\nFailing Test:\n')
      console.log(testCase)
      console.log()
      if (argv.print !== false) {
        const testPath = await writeTest(testCase, signature, failingTestRoot)
        console.log()
      }
    }
  }
}

async function generateTestCase (err, failingTestRoot, argv) {
  const template = await new Promise((resolve, reject) => {
    fs.readFile(TEMPLATE_PATH, { encoding: 'utf8' }, (err, contents) => {
      if (err) return reject(err)
      return resolve(contents)
    })
  })

  const trace = err[consts.Trace]
  const operations = trace.map(t => `await op.${t.name}(${JSON.stringify(t.inputs).slice(1).slice(0, -1)})`).join('\n  ')
  const testName = err[consts.TestName]
  const testArgs = JSON.stringify([...err[consts.TestArgs]]).slice(1).slice(0, -1)
  const signature = shasum(JSON.stringify({ operations, testName, testArgs }))

  const replacements = new Map([
    ['operations', operations],
    ['modulePath', p.relative(failingTestRoot, argv.module)],
    ['config', JSON.stringify(err[consts.Config], null, 1)],
    ['description', JSON.stringify(err[consts.Description])],
    ['testName', testName],
    ['testArgs', testArgs],
    ['signature', signature],
    ['timestamp', (new Date()).toString()]
  ])

  var testCase = template
  for (const [name, value] of replacements) {
    testCase = testCase.replace(new RegExp(`\{\{ ${name} \}\}`, 'g'), value)
  }

  return { testCase, signature }

  function shasum (testCase) {
    const sha = crypto.createHash('sha256')
    sha.update(testCase)
    return sha.digest('hex')
  }
}

async function getPath (failingTestRoot, testCase, signature, offset = 8) {
  const signatureRegex = /\/\/ @FUZZ_SIGNATURE (.*)/g
  var name = p.join(failingTestRoot, `test-${signature.slice(0, offset)}.js`)

  const { exists, continue: cont } = await checkIfExists()
  if (!exists) return name
  if (!cont) return null

  if (offset >= signature.length) return null
  return getPath(failingTestRoot, testCase, signature, offset + 8)

  function checkIfExists () {
    return new Promise((resolve, reject) => {
      fs.readFile(name, { encoding: 'utf8' }, (err, contents) => {
        if (err && err.errno !== -2 && err.errno !== -20) return reject(err)
        if (err) return resolve({ exists: false, continue: false})

        const signatureMatch = signatureRegex.exec(contents)
        if (!signatureMatch) return resolve({ exists: false, continue: false})
        const existingSignature = signatureMatch[1]
        if (existingSignature === signature) return resolve({ exists: true, continue: false})

        return resolve({ exists: true, continue: true })
      })
    })
  }
}

async function writeTest (testCase, signature, failingTestRoot) {
  const testPath = await getPath(failingTestRoot, testCase, signature)
  if (!testPath) {
    console.log('Test case already exists. Not overwriting.')
    return
  }
  await new Promise((resolve, reject) => {
    mkdirp(failingTestRoot, err => {
      if (err) return reject(err)
      return resolve()
    })
  })
  await new Promise((resolve, reject) => {
    fs.writeFile(testPath, testCase, { encoding: 'utf8'}, err => {
      if (err) return reject(err)
      return resolve()
    })
  })
  console.log(`Test case written to: ${testPath}`)
  return testPath
}

